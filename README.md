# STM32cubeMX
在选择板子的时候最好选到STM32F746G-Discovery，创建工程后再把pinOUT清空。

UART可以参考YouTube那个印度人的教学视频。


------------------------------------------------------------------

# Keil
## CMSIS
手动添加CMSIS记得把path加到c++的项目里面，还需要把cubeMX生成的CMSIS路径都给换到自己的CMSIS库中，可能因为版本不一致导致include的问题。

但是CMSIS/Device/ST在原始的库下不存在，是从cubeMX复制过去的。

## stdio
需要开启Compiler -> I/O -> stdout(user)

然后创建以下函数，printf底层接口是调用这个函数实现的：
```c
int stdout_putchar(int ch)
{
    HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);
    return ch;
}
```

## 添加外部文件
添加外部文件后需要去Keil中选择Manage Item，把`.c`文件添加进去才能正常编译，`.h`文件不用手动添加。



------------------------------------------------------------------

# CMSIS-NN

针对各种算子进行尝试，了解使用规则。

<!------------------------ 分割线 ------------------------->

## Relu
Relu不需要说明，给定一个一维数组，把里面小于0的元素全部变成0再返回。需要注意的是这个是会修改输入数组的，因为没有单独分配输出数组的空间。


## Polling

分为单通道和多通道进行说明，但其实单通道就是多通道的一种特殊情况。

### 单通道

输入：
```
-1  0  1  2
 2  3  5  4
 7  0  0  0
-1 -2  0  9
```

其实就是定义一个一维数组，然后设置`input_dim=4`，但就可以发现，这种接口方式只支持方形。顺序其实就是按行输入。
```c
q7_t in_vec[] = {-1, 0, 1, 2, 2, 3, 5, 4, 7, 0, 0, 0, -1, -2, 0, 9};
```

其次要定义好输出的`output_dim`和`buffer`，同样是一维数组，按行输出。

### 多通道
这里以2通道为例子

输入：
```
channel 1:

-1  0  1  2
 2  3  5  4
 7  0  0  0
-1 -2  0  9


channel 2:

-1  0  1  2
 2  3  5  4
 7  0  0  0
-1 -2  0  9
```

此时`in_vec`需要构建成：
```c
q7_t in_vec[] = {-1, -1, 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 5, 5, 4, 4,
                7, 7, 0, 0, 0, 0, 0, 0, -1, -1, -2, -2, 0, 0, 9, 9};
```

也就是先通道，再行扫描。

输出的顺序也是闲通道，再行扫描：
```
output_vec: 3, 3, 5, 5, 7, 7, 9, 9
```

<!------------------------ 分割线 ------------------------->

## Conv

注意，看函数名就可以知道应该用什么顺序了。例1和例2使用函数：`arm_convolve_HWC_q7_basic`

### 例1

#### 期望得到的计算

卷积提供了正方形的和非正方形的，这里以正方形的为例子

输入：
```
channel 1:

1  1  1  1
1  1  1  1
1  1  1  1
1  1  1  1


channel 2:

2  2  2  2
2  2  2  2
2  2  2  2
2  2  2  2
```

卷积核：
```
卷积核1:

2 2 2
2 2 2
2 2 2

3 3 3
3 3 3
3 3 3


卷积核2:

3 3 3
3 3 3
3 3 3

1 1 1
1 1 1
1 1 1
```

输出：
```
72  72
72  72

45  45
45  45
```

#### 上板测试

那么，需要构建输入一维向量：
```c
q7_t in_vec[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2};
q7_t weight[] = {2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1};
```

输出：
```
Output vector: 72 45 72 45 72 45 72 45
```

#### 分析

说明**输入和输出**向量的顺序：
```
{pos1, pos2, channle}
```

**权重**的顺序：
```
{in channel, pos1, pos2, out channel}
```

因此，目前需要确认的就是这个pos1和pos2是什么顺序。

答案：
```
NHWC
```


### 例2

#### 期望得到的计算

输入：
```
channel 1:

1  2  3  4
5  6  7  8
9  1  2  3
4  5  6  7


channel 2:

1  1  1  1
1  1  1  1
1  1  1  1
1  1  1  1
```

卷积核：
```
卷积核1:

2 2 2
2 2 2
2 2 2

-1 -2 -3
-4 -5 -6
-7 -8 -9


卷积核2:

1 2 3
1 2 3
1 2 3

1 1 1
1 1 1
1 1 1
```

输出(需要注意结果不能超出int 8的范围)：
```
27  27
45  45

78  87
96  105
```

#### 上板测试

输入一维向量：
```c
q7_t in_vec[] = {1, 1, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 7, 1, 8, 1, 9, 1, 1, 1, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 7, 1};
q7_t weight[] = {2, -1, 2, -2, 2, -3, 2, -4, 2, -5, 2, -6, 2, -7, 2, -8, 2, -9, 1, 1, 2, 1, 3, 1, 1, 1, 2, 1, 3, 1, 1, 1, 2, 1, 3, 1};
```

输出：
```
Output vector: 27 78 27 87 45 96 45 105 
```

#### 分析
基本可以确定顺序(太愚蠢了，函数名字都已经告诉我们一切)：
```
NHWC(输入没有那个N)
```

<!------------------------ 分割线 ------------------------->

## Dense

全连接层，使用函数：`arm_fully_connected_q7`

全连接层使用也很简单，依照公式：
```
output = np.matmul(weight, in_vec)
```

权重按照`HW`的顺序给，那么in_vec的长度一定是`W`，最后输出的长度就是`H`

------------------------------------------------------------------

# Vscode
Vscode上面的一些配置

## includePath
创建config：
```
command + shift + p: c/c++ edit config
```

然后修改里面的path，path可以参考keil，创建好的文件在`.vscode/c_cpp_properties.json`中

## SFTP
主要是windows侧要用Freesshd开启SFTP服务，然后vscode和windows传输的时候若启用`useTempFile`字段，那么将会造成temp file最后有个.new的后缀名无法删除，因为没有进一步修改文件的权限。
所以这个字段不能开。

------------------------------------------------------------------

# TODO

TFLite针对weight是零点为0，但是针对input、output零点范围是[-128,127]的（[链接](https://tensorflow.google.cn/lite/performance/quantization_spec?hl=zh-cn)）

因此，需要修改卷积啥的接口，在里面添加对应的零点偏移量化处理，让推理能够正常进行。实际上应该加一个input_zero_point和一个output_zero_point就行。